<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>DAE Debug Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: monospace;
            background: #1a1a1a;
            color: white;
            display: flex;
            gap: 20px;
        }
        
        .left {
            width: 400px;
        }
        
        .right {
            flex: 1;
            position: relative;
        }
        
        .upload-area {
            border: 2px dashed #4fc3f7;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            background: #2d2d2d;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover {
            background: #3d3d3d;
            border-color: #29b6f6;
        }
        
        .upload-area.dragover {
            background: #4fc3f7;
            color: #1a1a1a;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .log {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-info { color: #4fc3f7; }
        .log-success { color: #4caf50; }
        .log-warning { color: #ff9800; }
        .log-error { color: #f44336; }
        
        .file-info {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .file-info h3 {
            margin: 0 0 10px 0;
            color: #4fc3f7;
        }
        
        .clear-btn {
            background: #f44336;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        
        #canvas {
            width: 100%;
            height: 500px;
            border: 1px solid #444;
            border-radius: 10px;
            background: linear-gradient(45deg, #1e1e1e, #2a2a2a);
        }
        
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: #4fc3f7;
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .control-btn:hover {
            background: #29b6f6;
        }
        
        .xml-preview {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
        }
        
        .xml-preview h3 {
            margin: 0 0 10px 0;
            color: #4fc3f7;
        }
        
        .xml-content {
            color: #ccc;
            white-space: pre;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="left">
        <div class="upload-area" onclick="document.getElementById('fileInput').click()" 
             ondrop="handleDrop(event)" 
             ondragover="handleDragOver(event)" 
             ondragleave="handleDragLeave(event)">
            <h3>üìÅ Carica File DAE</h3>
            <p>Click qui o trascina il file</p>
            <input type="file" id="fileInput" accept=".dae,.obj,.xml" onchange="handleFile(event)">
            <small style="color: #888;">Supporta: .dae, .obj, .xml</small>
        </div>
        
        <div class="file-info" id="fileInfo" style="display: none;">
            <h3>üìÑ Info File</h3>
            <div id="fileDetails"></div>
        </div>
        
        <button class="clear-btn" onclick="clearLog()">üóëÔ∏è Pulisci Log</button>
        
        <div class="log" id="log">
            <div class="log-entry log-info">üöÄ DAE Debug Viewer inizializzato</div>
            <div class="log-entry log-info">üìã Drag & drop o click per caricare file</div>
        </div>
        
        <div class="xml-preview" id="xmlPreview" style="display: none;">
            <h3>üìã Anteprima XML</h3>
            <div class="xml-content" id="xmlContent"></div>
        </div>
    </div>
    
    <div class="right">
        <div id="canvas"></div>
        
        <div class="controls">
            <button class="control-btn" onclick="resetView()">üè† Reset Vista</button>
            <button class="control-btn" onclick="toggleWireframe()">üìê Wireframe</button>
            <button class="control-btn" onclick="createTestModel()">üß™ Test Model</button>
            <button class="control-btn" onclick="analyzeXML()">üîç Analizza XML</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer;
        let loadedModel = null;
        let currentFileContent = '';
        let currentFileName = '';
        let isWireframe = false;
        
        // Camera controls
        let spherical = { theta: Math.PI * 0.25, phi: Math.PI * 0.3, radius: 10 };
        let target = { x: 0, y: 0, z: 0 };
        let isRotating = false;
        let lastMouse = { x: 0, y: 0 };
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            
            const icons = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'warning': '‚ö†Ô∏è',
                'error': '‚ùå'
            };
            
            entry.textContent = `${timestamp} ${icons[type]} ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('Log pulito');
        }
        
        function init() {
            log('Inizializzazione Three.js viewer...');
            
            const container = document.getElementById('canvas');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            
            // Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            updateCamera();
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Grid
            const grid = new THREE.GridHelper(20, 20);
            scene.add(grid);
            
            // Mouse controls
            setupControls();
            
            // Start rendering
            animate();
            
            log('Viewer inizializzato con successo', 'success');
        }
        
        function setupControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (event) => {
                isRotating = true;
                lastMouse = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (!isRotating) return;
                
                const deltaX = event.clientX - lastMouse.x;
                const deltaY = event.clientY - lastMouse.y;
                
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi));
                
                lastMouse = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                isRotating = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                spherical.radius *= event.deltaY > 0 ? 1.1 : 0.9;
                spherical.radius = Math.max(1, Math.min(50, spherical.radius));
                event.preventDefault();
            });
        }
        
        function updateCamera() {
            const offset = new THREE.Vector3();
            offset.setFromSpherical(new THREE.Spherical(spherical.radius, spherical.phi, spherical.theta));
            camera.position.set(target.x + offset.x, target.y + offset.y, target.z + offset.z);
            camera.lookAt(target.x, target.y, target.z);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updateCamera();
            renderer.render(scene, camera);
        }
        
        // File handling
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }
        
        function handleFile(event) {
            const file = event.target.files[0];
            if (file) {
                processFile(file);
            }
        }
        
        async function processFile(file) {
            log(`Elaborazione file: ${file.name} (${file.size} bytes)`);
            
            currentFileName = file.name;
            
            // Show file info
            const fileInfo = document.getElementById('fileInfo');
            const fileDetails = document.getElementById('fileDetails');
            fileDetails.innerHTML = `
                <strong>Nome:</strong> ${file.name}<br>
                <strong>Dimensione:</strong> ${(file.size / 1024).toFixed(2)} KB<br>
                <strong>Tipo:</strong> ${file.type || 'sconosciuto'}<br>
                <strong>Modificato:</strong> ${new Date(file.lastModified).toLocaleString()}
            `;
            fileInfo.style.display = 'block';
            
            try {
                log('Lettura contenuto file...');
                const text = await file.text();
                currentFileContent = text;
                
                log(`File letto: ${text.length} caratteri`, 'success');
                log(`Prime 200 caratteri: ${text.substring(0, 200)}`);
                
                // Show XML preview
                showXMLPreview(text);
                
                const extension = file.name.toLowerCase().split('.').pop();
                log(`Estensione rilevata: .${extension}`);
                
                switch (extension) {
                    case 'dae':
                    case 'xml':
                        await parseDAE(text, file.name);
                        break;
                    case 'obj':
                        await parseOBJ(text, file.name);
                        break;
                    default:
                        log(`Estensione .${extension} non supportata`, 'warning');
                        log('Tentativo di parsing come DAE...', 'warning');
                        await parseDAE(text, file.name);
                }
                
            } catch (error) {
                log(`Errore lettura file: ${error.message}`, 'error');
                log(`Stack trace: ${error.stack}`, 'error');
            }
        }
        
        function showXMLPreview(content) {
            const preview = document.getElementById('xmlPreview');
            const xmlContent = document.getElementById('xmlContent');
            
            // Show first 1000 characters with basic formatting
            let preview_text = content.substring(0, 1000);
            if (content.length > 1000) {
                preview_text += '\n\n... (troncato)';
            }
            
            xmlContent.textContent = preview_text;
            preview.style.display = 'block';
        }
        
        async function parseDAE(daeText, filename) {
            log('üîç Inizio parsing DAE...');
            log(`Analisi file: ${filename}`);
            
            try {
                // Step 1: Parse XML
                log('Step 1: Parsing XML...');
                const parser = new DOMParser();
                const doc = parser.parseFromString(daeText, 'text/xml');
                
                // Check for parsing errors
                const parseError = doc.querySelector('parsererror');
                if (parseError) {
                    log(`Errore parsing XML: ${parseError.textContent}`, 'error');
                    throw new Error('File XML non valido');
                }
                log('XML parsing OK', 'success');
                
                // Step 2: Analyze document structure
                log('Step 2: Analisi struttura documento...');
                const root = doc.documentElement;
                log(`Root element: ${root.tagName}`);
                log(`Namespace: ${root.namespaceURI || 'nessuno'}`);
                
                // Find key elements
                const geometries = doc.querySelectorAll('geometry');
                const meshes = doc.querySelectorAll('mesh');
                const sources = doc.querySelectorAll('source');
                const libraries = doc.querySelectorAll('library_geometries, library_visual_scenes, library_materials');
                
                log(`Trovati elementi:`);
                log(`  - ${libraries.length} librerie`);
                log(`  - ${geometries.length} geometrie`);
                log(`  - ${meshes.length} mesh`);
                log(`  - ${sources.length} sources`);
                
                if (geometries.length === 0 && meshes.length === 0) {
                    log('Nessuna geometria trovata nel file DAE', 'warning');
                    log('Contenuti principali trovati:', 'info');
                    
                    // List all major elements
                    const allElements = doc.querySelectorAll('*');
                    const elementCounts = {};
                    
                    for (let elem of allElements) {
                        const tagName = elem.tagName;
                        elementCounts[tagName] = (elementCounts[tagName] || 0) + 1;
                    }
                    
                    // Show most common elements
                    const sortedElements = Object.entries(elementCounts)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10);
                    
                    for (let [tag, count] of sortedElements) {
                        log(`  - ${tag}: ${count}`);
                    }
                    
                    createFallbackModel(filename);
                    return;
                }
                
                // Step 3: Process geometries
                log('Step 3: Processing geometries...');
                const group = new THREE.Group();
                group.name = filename;
                
                let successCount = 0;
                
                // Try to process each mesh
                for (let i = 0; i < meshes.length; i++) {
                    log(`Processing mesh ${i + 1}/${meshes.length}...`);
                    
                    try {
                        const geometry = await extractGeometry(meshes[i], i);
                        if (geometry) {
                            const material = new THREE.MeshLambertMaterial({
                                color: new THREE.Color().setHSL((i * 0.1) % 1, 0.7, 0.6),
                                side: THREE.DoubleSide
                            });
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.name = `Mesh_${i}`;
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            group.add(mesh);
                            successCount++;
                            
                            log(`Mesh ${i + 1} aggiunta con successo`, 'success');
                        }
                    } catch (error) {
                        log(`Errore mesh ${i + 1}: ${error.message}`, 'error');
                    }
                }
                
                if (successCount === 0) {
                    log('Nessuna mesh valida creata, uso modello fallback', 'warning');
                    createFallbackModel(filename);
                    return;
                }
                
                // Add to scene
                addModelToScene(group);
                log(`DAE parsing completato: ${successCount} mesh create`, 'success');
                
            } catch (error) {
                log(`Errore critico parsing DAE: ${error.message}`, 'error');
                log(`Stack: ${error.stack}`, 'error');
                createFallbackModel(filename);
            }
        }
        
        async function extractGeometry(meshElement, index) {
            log(`  Estrazione geometria mesh ${index}...`);
            
            const sources = meshElement.querySelectorAll('source');
            const triangles = meshElement.querySelector('triangles, polylist, polygons');
            
            log(`    Sources trovate: ${sources.length}`);
            log(`    Triangulation: ${triangles ? triangles.tagName : 'nessuna'}`);
            
            if (!triangles) {
                log(`    Nessun elemento di triangolazione trovato`, 'warning');
                return null;
            }
            
            // Extract positions
            let positions = [];
            let positionSource = null;
            
            for (let j = 0; j < sources.length; j++) {
                const source = sources[j];
                const sourceId = source.getAttribute('id') || `source_${j}`;
                const floatArray = source.querySelector('float_array');
                
                log(`    Analisi source ${j + 1}: ${sourceId}`);
                
                if (floatArray) {
                    const count = parseInt(floatArray.getAttribute('count')) || 0;
                    const values = floatArray.textContent.trim().split(/\s+/).map(Number);
                    
                    log(`      Float array: ${count} valori dichiarati, ${values.length} trovati`);
                    
                    if (values.length > 0 && !positions.length) {
                        positions = values;
                        positionSource = sourceId;
                        log(`      Usato come posizioni: ${values.length/3} vertici`, 'success');
                        break;
                    }
                }
            }
            
            if (positions.length === 0) {
                log(`    Nessuna posizione trovata`, 'warning');
                return null;
            }
            
            // Extract indices
            const pElement = triangles.querySelector('p');
            if (!pElement) {
                log(`    Nessun elemento 'p' per gli indici`, 'warning');
                return null;
            }
            
            const triangleCount = parseInt(triangles.getAttribute('count')) || 0;
            const allIndices = pElement.textContent.trim().split(/\s+/).map(Number);
            const inputs = triangles.querySelectorAll('input');
            const stride = Math.max(inputs.length, 1);
            
            log(`    Triangoli dichiarati: ${triangleCount}`);
            log(`    Indici totali: ${allIndices.length}`);
            log(`    Stride: ${stride}`);
            log(`    Input elements: ${inputs.length}`);
            
            // List input semantics
            for (let k = 0; k < inputs.length; k++) {
                const input = inputs[k];
                const semantic = input.getAttribute('semantic');
                const source = input.getAttribute('source');
                const offset = input.getAttribute('offset');
                log(`      Input ${k}: ${semantic} -> ${source} (offset: ${offset})`);
            }
            
            // Extract vertex indices
            const vertexIndices = [];
            for (let i = 0; i < allIndices.length; i += stride) {
                vertexIndices.push(allIndices[i]);
            }
            
            log(`    Indici vertici estratti: ${vertexIndices.length}`);
            log(`    Triangoli calcolati: ${vertexIndices.length / 3}`);
            
            // Validate indices
            const maxIndex = Math.max(...vertexIndices);
            const vertexCount = positions.length / 3;
            
            log(`    Validazione: max indice ${maxIndex}, vertici disponibili ${vertexCount}`);
            
            if (maxIndex >= vertexCount) {
                log(`    Errore validazione: indice ${maxIndex} >= ${vertexCount}`, 'error');
                return null;
            }
            
            // Create geometry
            try {
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setIndex(vertexIndices);
                geometry.computeVertexNormals();
                geometry.computeBoundingBox();
                
                log(`    Geometria creata con successo`, 'success');
                return geometry;
                
            } catch (error) {
                log(`    Errore creazione geometria: ${error.message}`, 'error');
                return null;
            }
        }
        
        async function parseOBJ(objText, filename) {
            log('üîç Parsing OBJ...');
            // Implementation similar to DAE but for OBJ format
            // For now, create a simple fallback
            createFallbackModel(filename);
        }
        
        function createFallbackModel(filename) {
            log(`Creazione modello fallback per: ${filename}`, 'warning');
            
            const group = new THREE.Group();
            group.name = filename + ' (Fallback)';
            
            // Create a colorful test structure
            const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7];
            
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: colors[i] });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(
                    (i - 2) * 1.5,
                    Math.sin(i) * 0.5,
                    0
                );
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            }
            
            addModelToScene(group);
            log('Modello fallback creato', 'success');
        }
        
        function addModelToScene(model) {
            // Remove previous model
            if (loadedModel) {
                scene.remove(loadedModel);
                log('Modello precedente rimosso');
            }
            
            scene.add(model);
            loadedModel = model;
            
            // Focus on model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3()).length();
            
            target.x = center.x;
            target.y = center.y;
            target.z = center.z;
            spherical.radius = size * 2;
            
            log(`Modello aggiunto alla scena: ${model.name}`, 'success');
            log(`Centro: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})`);
            log(`Dimensione: ${size.toFixed(2)}`);
        }
        
        // Control functions
        function resetView() {
            spherical.theta = Math.PI * 0.25;
            spherical.phi = Math.PI * 0.3;
            spherical.radius = 10;
            target.x = target.y = target.z = 0;
            log('Vista resettata');
        }
        
        function toggleWireframe() {
            isWireframe = !isWireframe;
            
            if (loadedModel) {
                loadedModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = isWireframe;
                    }
                });
                log(`Wireframe: ${isWireframe ? 'ON' : 'OFF'}`);
            }
        }
        
        function createTestModel() {
            log('Creazione modello di test...');
            
            const group = new THREE.Group();
            group.name = 'Test Model';
            
            // House
            const houseGeometry = new THREE.BoxGeometry(4, 3, 4);
            const houseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.y = 1.5;
            house.castShadow = true;
            house.receiveShadow = true;
            group.add(house);
            
            // Roof
            const roofGeometry = new THREE.ConeGeometry(3, 2, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            group.add(roof);
            
            addModelToScene(group);
            log('Modello di test creato', 'success');
        }
        
        function analyzeXML() {
            if (!currentFileContent) {
                log('Nessun file caricato da analizzare', 'warning');
                return;
            }
            
            log('üîç Analisi dettagliata XML...');
            
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(currentFileContent, 'text/xml');
                
                // Analyze all elements
                const allElements = doc.querySelectorAll('*');
                const elementStats = {};
                const namespaces = new Set();
                
                for (let elem of allElements) {
                    const tagName = elem.tagName;
                    elementStats[tagName] = (elementStats[tagName] || 0) + 1;
                    
                    if (elem.namespaceURI) {
                        namespaces.add(elem.namespaceURI);
                    }
                }
                
                log(`Elementi totali: ${allElements.length}`);
                log(`Tipi di elementi: ${Object.keys(elementStats).length}`);
                log(`Namespaces: ${namespaces.size}`);
                
                // Show namespaces
                for (let ns of namespaces) {
                    log(`  Namespace: ${ns}`);
                }
                
                // Show element statistics
                const sortedStats = Object.entries(elementStats)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 20);
                
                log('Top 20 elementi per frequenza:');
                for (let [tag, count] of sortedStats) {
                    log(`  ${tag}: ${count}`);
                }
                
                // Look for specific DAE elements
                const daeElements = [
                    'COLLADA', 'asset', 'library_geometries', 'library_visual_scenes',
                    'geometry', 'mesh', 'source', 'float_array', 'triangles',
                    'polylist', 'polygons', 'vertices', 'input'
                ];
                
                log('Elementi DAE specifici:');
                for (let elemName of daeElements) {
                    const count = doc.querySelectorAll(elemName).length;
                    if (count > 0) {
                        log(`  ${elemName}: ${count}`, 'success');
                    } else {
                        log(`  ${elemName}: 0`, 'warning');
                    }
                }
                
            } catch (error) {
                log(`Errore analisi XML: ${error.message}`, 'error');
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            init();
            log('Pagina caricata, viewer pronto', 'success');
            log('Trascina un file DAE o click per caricarlo', 'info');
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>
