<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer DAE - Funzionante</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            height: 100vh;
            overflow: hidden;
        }
        
        .header {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }
        
        .buttons {
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-secondary {
            background: #10b981;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #059669;
        }
        
        .viewer {
            height: calc(100vh - 70px);
            position: relative;
            background: #f8f9fa;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .control-btn {
            width: 40px;
            height: 40px;
            margin: 5px;
            background: #f3f4f6;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-btn:hover {
            background: #e5e7eb;
        }
        
        .control-btn.active {
            background: #3b82f6;
            color: white;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            max-width: 300px;
            font-size: 14px;
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-box {
            background: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
        }
        
        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f6;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status {
            background: #e0f2fe;
            border: 1px solid #81d4fa;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
        }
        
        .error {
            background: #ffebee;
            border: 1px solid #ffcdd2;
            color: #c62828;
        }
        
        .success {
            background: #e8f5e8;
            border: 1px solid #a5d6a7;
            color: #2e7d32;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">üéØ 3D Viewer DAE</div>
        <div class="buttons">
            <button class="btn-secondary" onclick="loadExample()">üè† Esempio</button>
            <button class="btn-primary" onclick="openFileDialog()">üìÅ Carica DAE</button>
            <input type="file" id="fileInput" accept=".dae,.obj,.gltf" style="display: none;" onchange="handleFileSelect(event)">
        </div>
    </div>
    
    <div class="viewer">
        <div id="canvas-container"></div>
        
        <div class="controls">
            <button class="control-btn" onclick="resetView()" title="Vista iniziale">üè†</button>
            <button class="control-btn" onclick="toggleWireframe()" title="Wireframe">üìê</button>
            <button class="control-btn active" onclick="toggleGrid()" title="Griglia">‚öè</button>
            <button class="control-btn" onclick="showInfo()" title="Info">‚ÑπÔ∏è</button>
        </div>
        
        <div class="info">
            <h4>üìã Stato Viewer</h4>
            <p>Pronto per caricare modelli 3D</p>
            
            <div class="status">
                <strong>Formati supportati:</strong><br>
                ‚Ä¢ .DAE (Collada da SketchUp)<br>
                ‚Ä¢ .OBJ (Wavefront)<br>
                ‚Ä¢ .GLTF (Standard web)
            </div>
            
            <div id="modelInfo" style="display: none;"></div>
        </div>
        
        <div class="loading" id="loading">
            <div class="loading-box">
                <div class="spinner"></div>
                <p><strong>Caricamento modello...</strong></p>
                <p style="font-size: 12px; color: #666;">Parsing geometria DAE</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Variabili globali
        let scene, camera, renderer, controls;
        let loadedModel = null;
        let grid = null;
        let isWireframe = false;
        let showGridFlag = true;
        
        // Funzioni di controllo file
        function openFileDialog() {
            console.log('üñ±Ô∏è Apertura dialog file...');
            const fileInput = document.getElementById('fileInput');
            fileInput.click();
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                console.log('üìÅ File selezionato:', file.name);
                loadFile(file);
            }
        }
        
        function loadExample() {
            console.log('üè† Caricamento esempio...');
            showLoading(true);
            
            // Simula un file DAE di esempio
            const exampleDAE = `<?xml version="1.0"?>
<COLLADA xmlns="http://www.collada.org/2005/11/COLLADASchema" version="1.4.1">
  <library_geometries>
    <geometry id="House-mesh">
      <mesh>
        <source id="House-positions">
          <float_array count="24">
            -2 0 -2  2 0 -2  2 4 -2 -2 4 -2
            -2 0  2  2 0  2  2 4  2 -2 4  2
          </float_array>
          <technique_common>
            <accessor source="#House-positions" count="8" stride="3">
              <param name="X" type="float"/>
              <param name="Y" type="float"/>
              <param name="Z" type="float"/>
            </accessor>
          </technique_common>
        </source>
        <vertices id="House-vertices">
          <input semantic="POSITION" source="#House-positions"/>
        </vertices>
        <triangles count="12">
          <input semantic="VERTEX" source="#House-vertices"/>
          <p>0 1 2 0 2 3 4 7 6 4 6 5 0 4 5 0 5 1 2 6 7 2 7 3 0 3 7 0 7 4 1 5 6 1 6 2</p>
        </triangles>
      </mesh>
    </geometry>
  </library_geometries>
</COLLADA>`;
            
            setTimeout(() => {
                try {
                    const model = parseDAE(exampleDAE, 'esempio_casa.dae');
                    if (model) {
                        addModelToScene(model);
                        updateStatus('‚úÖ Esempio caricato: Casa semplice', 'success');
                    }
                } catch (error) {
                    updateStatus('‚ùå Errore esempio: ' + error.message, 'error');
                }
                showLoading(false);
            }, 1000);
        }
        
        async function loadFile(file) {
            showLoading(true);
            updateStatus('üìñ Lettura file: ' + file.name, '');
            
            try {
                const text = await file.text();
                const extension = file.name.toLowerCase().split('.').pop();
                
                let model = null;
                
                switch (extension) {
                    case 'dae':
                        model = parseDAE(text, file.name);
                        break;
                    case 'obj':
                        model = parseOBJ(text, file.name);
                        break;
                    default:
                        throw new Error(`Formato .${extension} non supportato`);
                }
                
                if (model) {
                    addModelToScene(model);
                    updateStatus(`‚úÖ ${file.name} caricato con successo`, 'success');
                } else {
                    throw new Error('Nessuna geometria valida trovata');
                }
                
            } catch (error) {
                console.error('Errore caricamento:', error);
                updateStatus('‚ùå Errore: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        function parseDAE(daeText, filename) {
            console.log('üîç Parsing DAE:', filename);
            
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(daeText, 'text/xml');
                
                // Verifica errori parsing
                const parseError = doc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('File DAE non valido (errore XML)');
                }
                
                const group = new THREE.Group();
                group.name = filename;
                
                // Estrai materiali e texture
                const materials = extractMaterials(doc);
                console.log(`üé® Materiali trovati: ${Object.keys(materials).length}`);
                
                // Cerca geometrie
                const meshes = doc.querySelectorAll('mesh');
                console.log(`üìê Trovate ${meshes.length} mesh`);
                
                let geometryCount = 0;
                
                meshes.forEach((mesh, index) => {
                    try {
                        const geometry = extractGeometryFromMesh(mesh);
                        if (geometry) {
                            // Cerca materiale associato
                            let material = materials[`material_${index}`] || 
                                         Object.values(materials)[index] ||
                                         new THREE.MeshLambertMaterial({
                                            color: new THREE.Color().setHSL((index * 0.2) % 1, 0.7, 0.6)
                                         });
                            
                            const meshObj = new THREE.Mesh(geometry, material);
                            meshObj.castShadow = true;
                            meshObj.receiveShadow = true;
                            group.add(meshObj);
                            geometryCount++;
                        }
                    } catch (err) {
                        console.warn(`‚ö†Ô∏è Errore mesh ${index}:`, err);
                    }
                });
                
                if (geometryCount === 0) {
                    // Fallback: crea geometria semplice
                    const geometry = new THREE.BoxGeometry(2, 2, 2);
                    const material = new THREE.MeshLambertMaterial({ color: 0x8888aa });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.y = 1;
                    group.add(mesh);
                    console.log('‚ö†Ô∏è Usando geometria fallback');
                }
                
                console.log(`‚úÖ DAE processato: ${geometryCount} geometrie`);
                return group;
                
            } catch (error) {
                console.error('‚ùå Errore parsing DAE:', error);
                throw error;
            }
        }
        
        function extractMaterials(doc) {
            const materials = {};
            
            // Cerca definizioni materiali
            const materialElements = doc.querySelectorAll('material');
            const effectElements = doc.querySelectorAll('effect');
            const imageElements = doc.querySelectorAll('image');
            
            console.log(`üîç Trovati: ${materialElements.length} materiali, ${effectElements.length} effetti, ${imageElements.length} immagini`);
            
            // Mappa delle immagini
            const images = {};
            imageElements.forEach(img => {
                const id = img.getAttribute('id');
                const initFrom = img.querySelector('init_from');
                if (id && initFrom) {
                    images[id] = initFrom.textContent.trim();
                    console.log(`üñºÔ∏è Immagine ${id}: ${images[id]}`);
                }
            });
            
            // Processa materiali
            materialElements.forEach((material, index) => {
                const materialId = material.getAttribute('id') || `material_${index}`;
                
                // Cerca effetto associato
                const instanceEffect = material.querySelector('instance_effect');
                if (instanceEffect) {
                    const effectUrl = instanceEffect.getAttribute('url');
                    if (effectUrl) {
                        const effectId = effectUrl.replace('#', '');
                        const effect = doc.querySelector(`effect[id="${effectId}"]`);
                        
                        if (effect) {
                            const mat = createMaterialFromEffect(effect, images);
                            materials[materialId] = mat;
                            console.log(`‚úÖ Materiale ${materialId} creato`);
                        }
                    }
                }
                
                // Fallback: materiale colorato
                if (!materials[materialId]) {
                    materials[materialId] = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL((index * 0.15) % 1, 0.8, 0.6)
                    });
                }
            });
            
            return materials;
        }
        
        function createMaterialFromEffect(effect, images) {
            const materialData = {
                color: 0xffffff,
                map: null,
                transparent: false,
                opacity: 1.0
            };
            
            // Cerca propriet√† diffuse
            const diffuse = effect.querySelector('diffuse');
            if (diffuse) {
                // Cerca colore
                const color = diffuse.querySelector('color');
                if (color) {
                    const colorValues = color.textContent.trim().split(/\s+/).map(Number);
                    if (colorValues.length >= 3) {
                        materialData.color = new THREE.Color(colorValues[0], colorValues[1], colorValues[2]);
                        console.log(`üé® Colore diffuse: ${colorValues.join(', ')}`);
                    }
                }
                
                // Cerca texture
                const texture = diffuse.querySelector('texture');
                if (texture) {
                    const textureId = texture.getAttribute('texture');
                    const sampler = effect.querySelector(`newparam[sid="${textureId}"] sampler2D source`);
                    if (sampler) {
                        const surfaceId = sampler.textContent.trim();
                        const surface = effect.querySelector(`newparam[sid="${surfaceId}"] surface init_from`);
                        if (surface) {
                            const imageId = surface.textContent.trim();
                            const imagePath = images[imageId];
                            if (imagePath) {
                                try {
                                    // Carica texture
                                    const loader = new THREE.TextureLoader();
                                    materialData.map = loader.load(
                                        imagePath,
                                        (texture) => {
                                            console.log(`‚úÖ Texture caricata: ${imagePath}`);
                                            texture.wrapS = THREE.RepeatWrapping;
                                            texture.wrapT = THREE.RepeatWrapping;
                                            texture.flipY = false; // Fix per DAE
                                        },
                                        undefined,
                                        (error) => {
                                            console.warn(`‚ö†Ô∏è Errore caricamento texture ${imagePath}:`, error);
                                        }
                                    );
                                    console.log(`üñºÔ∏è Applicando texture: ${imagePath}`);
                                } catch (error) {
                                    console.warn(`‚ö†Ô∏è Errore texture: ${error}`);
                                }
                            }
                        }
                    }
                }
            }
            
            // Cerca trasparenza
            const transparency = effect.querySelector('transparency');
            if (transparency) {
                const transparencyValue = parseFloat(transparency.textContent);
                if (transparencyValue < 1.0) {
                    materialData.transparent = true;
                    materialData.opacity = transparencyValue;
                    console.log(`üëª Trasparenza: ${transparencyValue}`);
                }
            }
            
            // Crea materiale Three.js
            return new THREE.MeshLambertMaterial({
                color: materialData.color,
                map: materialData.map,
                transparent: materialData.transparent,
                opacity: materialData.opacity,
                side: THREE.DoubleSide // Utile per modelli SketchUp
            });
        }
        
        function extractGeometryFromMesh(meshElement) {
            // Cerca posizioni
            const sources = meshElement.querySelectorAll('source');
            const triangles = meshElement.querySelector('triangles, polylist, polygons');
            
            if (!triangles) return null;
            
            let positions = [];
            let normals = [];
            let uvs = [];
            
            // Estrai dati da sources
            for (let source of sources) {
                const floatArray = source.querySelector('float_array');
                if (!floatArray) continue;
                
                const values = floatArray.textContent.trim().split(/\s+/).map(Number);
                const sourceId = source.getAttribute('id');
                
                if (sourceId && sourceId.includes('position')) {
                    positions = values;
                    console.log(`üìç Posizioni: ${values.length/3} vertici`);
                } else if (sourceId && sourceId.includes('normal')) {
                    normals = values;
                    console.log(`üî∫ Normali: ${values.length/3} normali`);
                } else if (sourceId && (sourceId.includes('uv') || sourceId.includes('map'))) {
                    uvs = values;
                    console.log(`üó∫Ô∏è UV: ${values.length/2} coordinate texture`);
                } else if (positions.length === 0) {
                    // Fallback: primo array di numeri trovato
                    positions = values;
                }
            }
            
            if (positions.length === 0) return null;
            
            // Estrai indici
            const pElement = triangles.querySelector('p');
            if (!pElement) return null;
            
            const indices = pElement.textContent.trim().split(/\s+/).map(Number);
            const inputs = triangles.querySelectorAll('input');
            const inputCount = inputs.length || 1;
            
            // Mappa degli offset per ogni tipo di input
            const inputMap = {};
            inputs.forEach((input, i) => {
                const semantic = input.getAttribute('semantic');
                inputMap[semantic] = i;
            });
            
            // Filtra indici per vertici
            const vertexIndices = [];
            const normalIndices = [];
            const uvIndices = [];
            
            for (let i = 0; i < indices.length; i += inputCount) {
                // Indici vertici
                const vertexOffset = inputMap['VERTEX'] || inputMap['POSITION'] || 0;
                vertexIndices.push(indices[i + vertexOffset]);
                
                // Indici normali
                if (inputMap['NORMAL'] !== undefined && normals.length > 0) {
                    normalIndices.push(indices[i + inputMap['NORMAL']]);
                }
                
                // Indici UV
                if (inputMap['TEXCOORD'] !== undefined && uvs.length > 0) {
                    uvIndices.push(indices[i + inputMap['TEXCOORD']]);
                }
            }
            
            // Crea geometria
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setIndex(vertexIndices);
            
            // Aggiungi normali se disponibili
            if (normals.length > 0 && normalIndices.length > 0) {
                // Riordina normali secondo gli indici
                const orderedNormals = [];
                for (let i = 0; i < normalIndices.length; i++) {
                    const normalIndex = normalIndices[i];
                    orderedNormals.push(
                        normals[normalIndex * 3],
                        normals[normalIndex * 3 + 1],
                        normals[normalIndex * 3 + 2]
                    );
                }
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(orderedNormals, 3));
                console.log('‚úÖ Normali applicate');
            } else {
                geometry.computeVertexNormals();
                console.log('üîÑ Normali calcolate automaticamente');
            }
            
            // Aggiungi UV se disponibili
            if (uvs.length > 0 && uvIndices.length > 0) {
                const orderedUVs = [];
                for (let i = 0; i < uvIndices.length; i++) {
                    const uvIndex = uvIndices[i];
                    orderedUVs.push(
                        uvs[uvIndex * 2],
                        uvs[uvIndex * 2 + 1]
                    );
                }
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(orderedUVs, 2));
                console.log('‚úÖ Coordinate UV applicate');
            }
            
            console.log(`üìä Geometria: ${positions.length/3} vertici, ${vertexIndices.length/3} triangoli`);
            
            return geometry;
        }
        
        function parseOBJ(objText, filename) {
            console.log('üîç Parsing OBJ:', filename);
            
            const group = new THREE.Group();
            group.name = filename;
            
            const vertices = [];
            const faces = [];
            
            const lines = objText.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                
                if (line.startsWith('v ')) {
                    const coords = line.split(/\s+/).slice(1).map(Number);
                    vertices.push(...coords);
                } else if (line.startsWith('f ')) {
                    const faceData = line.split(/\s+/).slice(1);
                    const triangle = faceData.slice(0, 3).map(data => {
                        return parseInt(data.split('/')[0]) - 1;
                    });
                    faces.push(...triangle);
                }
            }
            
            if (vertices.length > 0 && faces.length > 0) {
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(faces);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshLambertMaterial({ color: 0x6699cc });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                group.add(mesh);
                console.log(`‚úÖ OBJ: ${vertices.length/3} vertici, ${faces.length/3} triangoli`);
            } else {
                throw new Error('File OBJ vuoto o non valido');
            }
            
            return group;
        }
        
        function addModelToScene(model) {
            // Rimuovi modello precedente
            if (loadedModel) {
                scene.remove(loadedModel);
            }
            
            scene.add(model);
            loadedModel = model;
            
            // Centra camera
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3()).length();
            
            camera.position.set(
                center.x + size * 0.8,
                center.y + size * 0.6,
                center.z + size * 0.8
            );
            camera.lookAt(center);
            
            // Aggiorna info
            updateModelInfo(model);
        }
        
        function updateModelInfo(model) {
            let meshCount = 0;
            let vertexCount = 0;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    meshCount++;
                    if (child.geometry && child.geometry.attributes.position) {
                        vertexCount += child.geometry.attributes.position.count;
                    }
                }
            });
            
            const info = document.getElementById('modelInfo');
            info.innerHTML = `
                <div class="status success">
                    <strong>üìÅ ${model.name}</strong><br>
                    üî∑ ${meshCount} mesh<br>
                    üìê ${vertexCount} vertici
                </div>
            `;
            info.style.display = 'block';
        }
        
        function updateStatus(message, type) {
            const info = document.querySelector('.info p');
            info.innerHTML = message;
            
            // Cambia colore in base al tipo
            if (type === 'error') {
                info.style.color = '#c62828';
            } else if (type === 'success') {
                info.style.color = '#2e7d32';
            } else {
                info.style.color = '#333';
            }
        }
        
        function showLoading(show) {
            const loading = document.getElementById('loading');
            loading.style.display = show ? 'flex' : 'none';
        }
        
        // Controlli
        function resetView() {
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleWireframe() {
            isWireframe = !isWireframe;
            if (loadedModel) {
                loadedModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = isWireframe;
                    }
                });
            }
            
            const btn = document.querySelector('[onclick="toggleWireframe()"]');
            btn.classList.toggle('active', isWireframe);
        }
        
        function toggleGrid() {
            showGridFlag = !showGridFlag;
            if (grid) {
                grid.visible = showGridFlag;
            }
            
            const btn = document.querySelector('[onclick="toggleGrid()"]');
            btn.classList.toggle('active', showGridFlag);
        }
        
        function showInfo() {
            if (loadedModel) {
                const box = new THREE.Box3().setFromObject(loadedModel);
                const size = box.getSize(new THREE.Vector3());
                alert(`üìä Info Modello:\n\nüìÅ Nome: ${loadedModel.name}\nüìè Dimensioni: ${size.x.toFixed(1)} √ó ${size.y.toFixed(1)} √ó ${size.z.toFixed(1)}`);
            } else {
                alert('Nessun modello caricato');
            }
        }
        
        // Inizializzazione Three.js
        function init() {
            console.log('üöÄ Inizializzazione 3D Viewer...');
            
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f4f8);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(5, 5, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Luci migliorate
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8); // Aumentata da 0.4 a 0.8
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2); // Aumentata da 0.8 a 1.2
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Aggiunge una seconda luce per eliminare ombre troppo scure
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight2.position.set(-10, 10, -10);
            scene.add(directionalLight2);
            
            // Luce hemisferica per illuminazione pi√π naturale
            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x8b7355, 0.5);
            scene.add(hemisphereLight);
            
            // Griglia
            grid = new THREE.GridHelper(10, 10, 0x888888, 0xcccccc);
            scene.add(grid);
            
            // Controlli mouse semplici
            setupSimpleControls();
            
            // Resize
            window.addEventListener('resize', onWindowResize);
            
            // Avvia rendering
            animate();
            
            console.log('‚úÖ Viewer pronto!');
            updateStatus('‚úÖ Viewer inizializzato - Pronto per caricare file', 'success');
        }
        
        function setupSimpleControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let currentRotationX = 0, currentRotationY = 0;
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                event.preventDefault();
            });
            
            // Smooth rotation
            function updateCamera() {
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                const distance = camera.position.length();
                camera.position.x = distance * Math.sin(currentRotationY) * Math.cos(currentRotationX);
                camera.position.y = distance * Math.sin(currentRotationX);
                camera.position.z = distance * Math.cos(currentRotationY) * Math.cos(currentRotationX);
                camera.lookAt(0, 0, 0);
                
                requestAnimationFrame(updateCamera);
            }
            updateCamera();
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Avvia quando il DOM √® pronto
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
